
import React, { useState, useEffect, useRef, FormEvent } from 'react';
import { useAuth } from '../App';
import { useNavigate } from 'react-router-dom';
import { doc, setDoc, onSnapshot, collection, query, where, getDocs, limit, serverTimestamp, addDoc, orderBy, deleteDoc, updateDoc, writeBatch, getDoc } from 'firebase/firestore';
import { db, auth } from '../services/firebase';
import { GenderPreference, Chat, Message, UserProfile, ChatParticipantInfo } from '../types';
import { signOut } from 'firebase/auth';
import { LogOut, Send, Users, X, Clock, Sparkles, Tv, MessageSquare, Search, FileImage, Flag, AlertTriangle, CheckCircle, User, CornerDownLeft, Smile } from 'lucide-react';

// Tenor API Configuration
const TENOR_API_KEY = 'AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ'; // Default Tenor test key
const TENOR_API_URL = 'https://tenor.googleapis.com/v2';

// --- GIF Picker Component ---
interface TenorGif {
  id: string;
  media_formats: {
    tinygif: { url: string };
    gif: { url: string };
  };
}

const GifPicker: React.FC<{ onSelectGif: (gifUrl: string) => void; onClose: () => void }> = ({ onSelectGif, onClose }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [gifs, setGifs] = useState<TenorGif[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Load featured/trending GIFs on mount
    fetchGifs('');
  }, []);

  const fetchGifs = async (search: string) => {
    setLoading(true);
    try {
      const endpoint = search ? 'search' : 'featured';
      const searchParam = search ? `&q=${encodeURIComponent(search)}` : '';
      const response = await fetch(
        `${TENOR_API_URL}/${endpoint}?key=${TENOR_API_KEY}${searchParam}&limit=20&media_filter=gif,tinygif`
      );
      const data = await response.json();
      setGifs(data.results || []);
    } catch (error) {
      console.error('Error fetching GIFs:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSearch = (e: FormEvent) => {
    e.preventDefault();
    fetchGifs(searchTerm);
  };

  return (
    <div className="absolute bottom-16 left-0 right-0 bg-dark-card border border-dark-surface rounded-t-xl shadow-2xl flex flex-col z-50" style={{ height: '280px' }}>
      <div className="px-2.5 py-2 border-b border-dark-surface flex items-center justify-between bg-dark-surface/50">
        <h3 className="font-semibold text-white flex items-center text-xs">
          <FileImage className="mr-1.5" size={16} />
          GIFs
        </h3>
        <button onClick={onClose} className="text-dark-text-secondary hover:text-white transition-colors">
          <X size={16} />
        </button>
      </div>
      
      <form onSubmit={handleSearch} className="p-1.5 bg-dark-surface/30">
        <div className="relative">
          <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 text-dark-text-secondary" size={14} />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder="Search..."
            className="w-full pl-8 pr-2 py-1 text-xs bg-dark-bg text-white rounded-md focus:outline-none focus:ring-1 focus:ring-brand-primary border border-dark-surface"
          />
        </div>
      </form>
      
      <div className="flex-1 overflow-y-auto p-1">
        {loading ? (
          <div className="flex justify-center items-center h-full">
            <div className="w-6 h-6 border-4 border-dashed rounded-full animate-spin border-brand-primary"></div>
          </div>
        ) : gifs.length > 0 ? (
          <div className="grid grid-cols-5 gap-0.5">
            {gifs.map((gif) => (
              <button
                key={gif.id}
                onClick={() => {
                  onSelectGif(gif.media_formats.gif.url);
                  onClose();
                }}
                className="relative rounded overflow-hidden hover:ring-1 hover:ring-brand-primary transition-all bg-dark-surface group aspect-square"
              >
                <img
                  src={gif.media_formats.tinygif.url}
                  alt="GIF"
                  className="w-full h-full object-cover group-hover:scale-110 transition-transform"
                />
              </button>
            ))}
          </div>
        ) : (
          <div className="flex justify-center items-center h-full text-dark-text-secondary text-xs">
            No GIFs found
          </div>
        )}
      </div>
      
      <div className="px-2 py-1 border-t border-dark-surface text-center text-[10px] text-dark-text-secondary bg-dark-surface/30">
        Powered by Tenor
      </div>
    </div>
  );
};

// --- Emoji Picker Component ---
const EmojiPicker: React.FC<{ onSelectEmoji: (emoji: string) => void; onClose: () => void }> = ({ onSelectEmoji, onClose }) => {
  const frequentEmojis = ['ÔøΩ', '', '‚ù§Ô∏è', 'ÔøΩ', 'üéâ', '', 'ÔøΩ', '‚ú®', 'ÔøΩ', 'ÔøΩ', 'ÔøΩ', '', 'ÔøΩ', '', 'ÔøΩ', 'ÔøΩ', 'üí™', 'ÔøΩ', 'ÔøΩ', 'ÔøΩ'];

  return (
    <div className="absolute bottom-full mb-2 left-0 right-0 bg-dark-bg border border-dark-surface rounded-full shadow-2xl z-50 px-3 py-2">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-1 flex-1 overflow-x-auto no-scrollbar">
          {frequentEmojis.map((emoji, index) => (
            <button
              key={index}
              onClick={() => {
                onSelectEmoji(emoji);
              }}
              className="text-2xl hover:scale-125 transition-transform flex-shrink-0 w-10 h-10 flex items-center justify-center rounded-full hover:bg-dark-surface"
              title="Click to insert"
            >
              {emoji}
            </button>
          ))}
        </div>
        <button 
          onClick={onClose} 
          className="text-dark-text-secondary hover:text-white transition-colors ml-2 p-1.5 rounded-full hover:bg-dark-surface flex-shrink-0"
          title="Close"
        >
          <X size={16} />
        </button>
      </div>
    </div>
  );
};

// --- Profile Modal Component ---
interface ProfileModalProps {
  profile: UserProfile;
  onClose: () => void;
  onBlock: () => void;
}

// Generate random avatar with initials
const generateProfileAvatar = (name: string, seed: string) => {
  const colors = [
    'bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 
    'bg-purple-500', 'bg-pink-500', 'bg-indigo-500', 'bg-teal-500'
  ];
  const colorIndex = seed.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % colors.length;
  const nameParts = name.trim().split(' ').filter(n => n.length > 0);
  const initials = nameParts.length > 1 
    ? (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase()
    : name.slice(0, 2).toUpperCase();
  
  return (
    <div className={`w-24 h-24 ${colors[colorIndex]} rounded-full flex items-center justify-center text-white text-3xl font-bold`}>
      {initials}
    </div>
  );
};

const ProfileModal: React.FC<ProfileModalProps> = ({ profile, onClose, onBlock }) => {
  const [showBlockConfirm, setShowBlockConfirm] = useState(false);

  const handleBlockUser = () => {
    onBlock();
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4" onClick={onClose}>
      <div className="bg-dark-card rounded-2xl shadow-2xl max-w-md w-full border-2 border-dark-surface" onClick={(e) => e.stopPropagation()}>
        <div className="p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-2xl font-bold text-white">User Profile</h2>
            <button onClick={onClose} className="text-dark-text-secondary hover:text-white transition-colors">
              <X size={24} />
            </button>
          </div>
          
          <div className="flex flex-col items-center mb-6">
            {profile.avatarUrl ? (
              <img 
                src={profile.avatarUrl} 
                alt="Profile" 
                className="w-24 h-24 rounded-full border-4 border-dark-surface object-cover"
              />
            ) : (
              generateProfileAvatar(profile.username, profile.uid)
            )}
          </div>

          <div className="space-y-4">
            <div>
              <label className="text-sm text-dark-text-secondary block mb-1">Username</label>
              <div className="bg-dark-bg p-3 rounded-lg border border-dark-surface">
                <span className="text-white font-medium">{profile.username}</span>
              </div>
            </div>

            <div>
              <label className="text-sm text-dark-text-secondary block mb-1">Gender</label>
              <div className="bg-dark-bg p-3 rounded-lg border border-dark-surface">
                <span className="text-white capitalize">{profile.gender}</span>
              </div>
            </div>

            <div>
              <label className="text-sm text-dark-text-secondary block mb-1">Bio</label>
              <div className="bg-dark-bg p-3 rounded-lg border border-dark-surface min-h-[80px]">
                <span className="text-white">{profile.bio || 'No bio available'}</span>
              </div>
            </div>
          </div>

          {/* Block Button */}
          <div className="mt-6 pt-4 border-t border-dark-surface">
            {!showBlockConfirm ? (
              <button
                onClick={() => setShowBlockConfirm(true)}
                className="w-full bg-red-600/20 hover:bg-red-600/30 text-red-500 font-bold py-3 px-4 rounded-lg transition-colors border border-red-600/50 flex items-center justify-center"
              >
                <X className="mr-2" size={18} />
                Block User
              </button>
            ) : (
              <div className="space-y-3">
                <p className="text-sm text-dark-text-secondary text-center">
                  Block this user? You won't be matched with them again.
                </p>
                <div className="flex space-x-2">
                  <button
                    onClick={() => setShowBlockConfirm(false)}
                    className="flex-1 bg-dark-surface hover:bg-dark-bg text-white font-bold py-2 px-4 rounded-lg transition-colors"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleBlockUser}
                    className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                  >
                    Block
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

// --- Leave Confirmation Modal ---
const LeaveConfirmationModal: React.FC<{ onConfirm: () => void; onCancel: () => void }> = ({ onConfirm, onCancel }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4">
      <div className="bg-dark-card rounded-2xl shadow-2xl max-w-md w-full border-2 border-dark-surface">
        <div className="p-6">
          <div className="flex items-center justify-center mb-4">
            <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center">
              <AlertTriangle className="text-red-500" size={32} />
            </div>
          </div>
          <h2 className="text-2xl font-bold text-center text-white mb-4">Leave Chat?</h2>
          <p className="text-dark-text-secondary text-center leading-relaxed mb-6">
            Are you sure you want to leave this chat? This will end the conversation for both users.
          </p>
          <div className="flex space-x-3">
            <button 
              onClick={onCancel}
              className="flex-1 bg-dark-surface hover:bg-dark-bg text-white font-bold py-3 px-4 rounded-lg transition-colors"
            >
              Stay
            </button>
            <button 
              onClick={onConfirm}
              className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors"
            >
              Leave Chat
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// --- Success Modal Component ---
const SuccessModal: React.FC<{ message: string; onClose: () => void }> = ({ message, onClose }) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose();
    }, 3000);
    return () => clearTimeout(timer);
  }, [onClose]);

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-dark-card rounded-2xl shadow-2xl max-w-md w-full border border-green-500/50 transform animate-scale-in">
        <div className="p-6 text-center">
          <div className="mx-auto w-16 h-16 bg-green-500/20 rounded-full flex items-center justify-center mb-4">
            <CheckCircle className="text-green-500" size={32} />
          </div>
          <h2 className="text-xl font-bold text-white mb-2">Success!</h2>
          <p className="text-dark-text-secondary">{message}</p>
          <button 
            onClick={onClose}
            className="mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors"
          >
            OK
          </button>
        </div>
      </div>
    </div>
  );
};

// --- Report Modal Component ---
const ReportModal: React.FC<{ onClose: () => void; onSubmit: (reason: string) => void }> = ({ onClose, onSubmit }) => {
  const [reason, setReason] = useState('');
  const [selectedReason, setSelectedReason] = useState('');

  const predefinedReasons = [
    'Inappropriate content',
    'Harassment or bullying',
    'Spam or advertising',
    'Hate speech',
    'Threatening behavior',
    'Other'
  ];

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const finalReason = selectedReason === 'Other' ? reason : selectedReason;
    if (finalReason.trim()) {
      onSubmit(finalReason);
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-dark-card rounded-2xl shadow-2xl max-w-md w-full border border-dark-surface">
        <div className="p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-bold text-white flex items-center">
              <Flag className="mr-2 text-red-500" size={24} />
              Report User
            </h2>
            <button onClick={onClose} className="text-dark-text-secondary hover:text-white transition-colors">
              <X size={24} />
            </button>
          </div>

          <div className="bg-yellow-500/10 border border-yellow-500/30 text-yellow-300 p-3 rounded-lg text-sm mb-4 flex items-start">
            <AlertTriangle className="mr-2 mt-0.5 flex-shrink-0" size={16} />
            <p>This will report the user and save the chat for admin review. False reports may result in action against your account.</p>
          </div>

          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-dark-text-secondary mb-2">Select a reason:</label>
              <div className="space-y-2">
                {predefinedReasons.map((r) => (
                  <label key={r} className="flex items-center p-3 bg-dark-surface rounded-lg cursor-pointer hover:bg-dark-surface/70 transition-colors">
                    <input
                      type="radio"
                      name="reason"
                      value={r}
                      checked={selectedReason === r}
                      onChange={(e) => setSelectedReason(e.target.value)}
                      className="h-4 w-4 text-brand-primary focus:ring-brand-primary"
                    />
                    <span className="ml-3 text-white">{r}</span>
                  </label>
                ))}
              </div>
            </div>

            {selectedReason === 'Other' && (
              <div>
                <label className="block text-sm font-medium text-dark-text-secondary mb-2">Please describe:</label>
                <textarea
                  value={reason}
                  onChange={(e) => setReason(e.target.value)}
                  placeholder="Describe the issue..."
                  className="w-full bg-dark-surface p-3 rounded-lg border border-dark-surface focus:outline-none focus:ring-2 focus:ring-brand-primary text-white min-h-[100px]"
                  required
                />
              </div>
            )}

            <div className="flex space-x-3 pt-2">
              <button
                type="button"
                onClick={onClose}
                className="flex-1 bg-dark-surface hover:bg-dark-surface/70 text-white font-bold py-3 px-4 rounded-lg transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={!selectedReason}
                className="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Submit Report
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};

// --- Warning Notification Modal ---
const WarningNotificationModal: React.FC<{ message: string; onClose: () => void }> = ({ message, onClose }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 p-4">
      <div className="bg-dark-card rounded-2xl shadow-2xl max-w-md w-full border-2 border-red-500">
        <div className="p-6">
          <div className="flex items-center justify-center mb-4">
            <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center">
              <AlertTriangle className="text-red-500" size={32} />
            </div>
          </div>
          <h2 className="text-2xl font-bold text-center text-white mb-4">Admin Warning</h2>
          <div className="bg-red-500/10 border border-red-500/30 p-4 rounded-lg mb-6">
            <p className="text-white text-center leading-relaxed">{message}</p>
          </div>
          <button 
            onClick={onClose}
            className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors"
          >
            I Understand
          </button>
        </div>
      </div>
    </div>
  );
};

// --- Header Component ---
const Header: React.FC<{ userProfile: UserProfile | null }> = ({ userProfile }) => {
    const navigate = useNavigate();
    
    return (
        <header className="absolute top-0 left-0 right-0 p-4 bg-dark-bg/50 backdrop-blur-sm z-30">
            <div className="container mx-auto flex justify-between items-center">
                <h1 className="text-2xl font-bold text-white flex items-center"><MessageSquare className="mr-2 text-brand-primary"/> UniChat</h1>
                {userProfile && (
                    <div className="flex items-center space-x-4">
                        <span className="text-dark-text-secondary">Welcome, {userProfile.username}</span>
                        <button
                            onClick={() => navigate('/profile')}
                            className="relative group"
                            aria-label="Profile"
                        >
                            {userProfile?.avatarUrl ? (
                                <img 
                                    src={userProfile.avatarUrl} 
                                    alt="Profile" 
                                    className="w-8 h-8 rounded-full object-cover ring-2 ring-dark-surface group-hover:ring-brand-primary transition-all"
                                />
                            ) : (
                                <div className={`w-8 h-8 rounded-full flex items-center justify-center text-white text-xs font-bold ring-2 ring-dark-surface group-hover:ring-brand-primary transition-all ${
                                    userProfile ? ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500', 'bg-pink-500', 'bg-indigo-500', 'bg-teal-500'][
                                        userProfile.uid.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 8
                                    ] : 'bg-gray-500'
                                }`}>
                                    {userProfile?.username?.slice(0, 2).toUpperCase() || 'U'}
                                </div>
                            )}
                        </button>
                        <button
                            onClick={() => signOut(auth)}
                            className="bg-dark-surface p-2 rounded-full text-dark-text-secondary hover:text-white hover:bg-red-500/50 transition-colors"
                            aria-label="Log Out"
                        >
                            <LogOut size={20} />
                        </button>
                    </div>
                )}
            </div>
        </header>
    );
};

// --- Chat Dashboard ---
const ChatDashboard: React.FC<{ onStartChat: (preference: GenderPreference) => void, onWatchAd: () => Promise<void> }> = ({ onStartChat, onWatchAd }) => {
    const { userProfile } = useAuth();
    const [preference, setPreference] = useState<GenderPreference>('any');
    const [adLoading, setAdLoading] = useState(false);

    const handleWatchAd = async () => {
        setAdLoading(true);
        await onWatchAd();
        setAdLoading(false);
    };

    const needsAd = preference !== 'any';
    const hasCredits = (userProfile?.adsWatched ?? 0) > 0;

    return (
        <div className="flex flex-col items-center justify-center h-full p-4">
            <div className="w-full max-w-lg text-center bg-dark-card/80 backdrop-blur-sm border border-dark-surface/50 rounded-2xl shadow-2xl p-8 space-y-6">
                <h2 className="text-4xl font-bold text-white">Find a Chat Partner</h2>
                <p className="text-dark-text-secondary">Connect with another student from your university. Choose your preference below and start chatting.</p>

                <div className="bg-dark-surface p-4 rounded-lg">
                    <h3 className="text-lg font-semibold mb-3 text-white">Gender Preference</h3>
                    <div className="flex justify-center space-x-2 sm:space-x-4">
                        {(['any', 'male', 'female'] as GenderPreference[]).map(p => (
                            <button
                                key={p}
                                onClick={() => setPreference(p)}
                                className={`px-4 py-2 rounded-full text-sm sm:text-base font-medium transition-all duration-200 ${preference === p ? 'bg-brand-primary text-white shadow-lg' : 'bg-dark-card hover:bg-dark-surface'}`}
                            >
                                {p.charAt(0).toUpperCase() + p.slice(1)}
                            </button>
                        ))}
                    </div>
                </div>

                {needsAd && (
                    <div className="bg-yellow-500/10 border border-yellow-500/30 text-yellow-300 p-3 rounded-lg text-sm space-y-2">
                        <p>Gender-filtered search requires one ad view per match.</p>
                        <p className="font-semibold">You have {userProfile?.adsWatched ?? 0} credit(s).</p>
                    </div>
                )}
                
                {needsAd && !hasCredits ? (
                    <button onClick={handleWatchAd} disabled={adLoading} className="w-full flex items-center justify-center bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:opacity-50">
                        <Tv className="mr-2"/>{adLoading ? 'Loading Ad...' : 'Watch Ad to Unlock'}
                    </button>
                ) : (
                    <button onClick={() => onStartChat(preference)} className="w-full flex items-center justify-center bg-brand-primary hover:bg-brand-secondary text-white font-bold py-3 px-4 rounded-lg transition-colors text-xl">
                       <Sparkles className="mr-2"/> Start Chatting
                    </button>
                )}
            </div>
        </div>
    );
};

// --- Matchmaking Modal ---
const MatchmakingModal: React.FC<{ onCancel: () => void }> = ({ onCancel }) => (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
        <div className="bg-dark-card rounded-2xl shadow-2xl p-8 text-center space-y-4 transform transition-all duration-300 animate-pulse">
            <div className="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-brand-primary mx-auto"></div>
            <h2 className="text-2xl font-bold text-white">Searching for a match...</h2>
            <p className="text-dark-text-secondary">Please wait while we connect you with another student.</p>
            <button onClick={onCancel} className="mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">
                Cancel
            </button>
        </div>
    </div>
);

// --- Chat Room ---
const ChatRoom: React.FC<{ chat: Chat, onLeave: () => void }> = ({ chat, onLeave }) => {
    const { currentUser, userProfile } = useAuth();
    const [messages, setMessages] = useState<Message[]>([]);
    const [newMessage, setNewMessage] = useState('');
    const [showGifPicker, setShowGifPicker] = useState(false);
    const [showReportModal, setShowReportModal] = useState(false);
    const [showSuccessModal, setShowSuccessModal] = useState(false);
    const [showProfileModal, setShowProfileModal] = useState(false);
    const [partnerProfile, setPartnerProfile] = useState<UserProfile | null>(null);
    const [showLeaveConfirmation, setShowLeaveConfirmation] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const [isPartnerTyping, setIsPartnerTyping] = useState(false);
    const [isPartnerViewingProfile, setIsPartnerViewingProfile] = useState(false);
    const [isPartnerSelectingGif, setIsPartnerSelectingGif] = useState(false);
    const [isPartnerOnline, setIsPartnerOnline] = useState(true);
    const [chatDuration, setChatDuration] = useState(0);
    const [replyingTo, setReplyingTo] = useState<Message | null>(null);
    const [showEmojiPicker, setShowEmojiPicker] = useState(false);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    // Fix: In a browser environment, setTimeout returns a number, not NodeJS.Timeout.
    const typingTimeoutRef = useRef<number | null>(null);
    
    const partnerId = chat.participants.find(p => p !== currentUser?.uid);
    const partnerInfo = partnerId ? chat.participantInfo[partnerId] : { username: 'User', isTyping: false, isViewingProfile: false };

    // Fetch partner profile
    useEffect(() => {
        if (!partnerId) return;
        const fetchPartnerProfile = async () => {
            const partnerDoc = await getDoc(doc(db, 'users', partnerId));
            if (partnerDoc.exists()) {
                setPartnerProfile(partnerDoc.data() as UserProfile);
            }
        };
        fetchPartnerProfile();
    }, [partnerId]);

    useEffect(() => {
        if (!chat.id) return;
        const q = query(collection(db, `chats/${chat.id}/messages`), orderBy('timestamp', 'asc'));
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const msgs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));
            setMessages(msgs);
        });
        return () => unsubscribe();
    }, [chat.id]);

    useEffect(() => {
        const chatUnsub = onSnapshot(doc(db, 'chats', chat.id), (doc) => {
            const chatData = doc.data() as Chat | undefined;
            if (!chatData || !partnerId) {
                // Chat has been deleted
                onLeave();
                return;
            }
            const partnerIsTyping = chatData.participantInfo?.[partnerId]?.isTyping ?? false;
            const partnerIsViewingProfile = chatData.participantInfo?.[partnerId]?.isViewingProfile ?? false;
            const partnerIsSelectingGif = chatData.participantInfo?.[partnerId]?.isSelectingGif ?? false;
            setIsPartnerTyping(partnerIsTyping);
            setIsPartnerViewingProfile(partnerIsViewingProfile);
            setIsPartnerSelectingGif(partnerIsSelectingGif);
        });

        return () => chatUnsub();
    }, [chat.id, partnerId, onLeave]);

    // Monitor partner's online status and auto-end chat if offline for 10 minutes
    useEffect(() => {
        if (!partnerId) return;

        const partnerRef = doc(db, 'users', partnerId);
        const unsubscribe = onSnapshot(partnerRef, async (docSnapshot) => {
            const partnerData = docSnapshot.data();
            
            if (partnerData) {
                // Update partner online status for UI
                setIsPartnerOnline(partnerData.isOnline || false);
                
                if (partnerData.lastSeen) {
                    const lastSeenTime = typeof partnerData.lastSeen === 'object' && 'seconds' in partnerData.lastSeen
                        ? partnerData.lastSeen.seconds * 1000
                        : new Date(partnerData.lastSeen).getTime();
                    
                    const now = Date.now();
                    const offlineTime = now - lastSeenTime;
                    const TEN_MINUTES = 10 * 60 * 1000; // 10 minutes in milliseconds
                    
                    // If partner has been offline for more than 10 minutes, end the chat
                    if (!partnerData.isOnline && offlineTime > TEN_MINUTES) {
                        try {
                            // Send system message about chat ending
                            await addDoc(collection(db, `chats/${chat.id}/messages`), {
                                senderId: 'system',
                                content: 'Chat ended: Partner was offline for more than 10 minutes.',
                                type: 'system',
                                timestamp: serverTimestamp()
                            });

                            // Delete chat after a short delay
                            setTimeout(async () => {
                                const chatRef = doc(db, 'chats', chat.id);
                                const batch = writeBatch(db);

                                // Delete all messages
                                const messagesQuery = query(collection(db, `chats/${chat.id}/messages`));
                                const messagesSnapshot = await getDocs(messagesQuery);
                                messagesSnapshot.forEach(msgDoc => batch.delete(msgDoc.ref));

                                // Delete chat
                                batch.delete(chatRef);

                                // Update participants
                                chat.participants.forEach(uid => {
                                    batch.update(doc(db, 'users', uid), { currentChatId: null });
                                });

                                await batch.commit();
                                onLeave();
                            }, 3000); // 3 second delay to show the message
                        } catch (error) {
                            console.error('Error auto-ending chat:', error);
                        }
                    }
                }
            }
        });

        return () => unsubscribe();
    }, [partnerId, chat.id, chat.participants, onLeave]);

     useEffect(() => {
        const timer = setInterval(() => {
            if (chat.startedAt) {
                const now = Date.now();
                // Handle both Firestore Timestamp and Date objects
                const startTime = typeof chat.startedAt === 'object' && 'seconds' in chat.startedAt 
                    ? chat.startedAt.seconds * 1000 
                    : new Date(chat.startedAt).getTime();
                setChatDuration(Math.floor((now - startTime) / 1000));
            }
        }, 1000);
        return () => clearInterval(timer);
    }, [chat.startedAt]);

    const formatDuration = (seconds: number) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    };

    const formatMessageTime = (timestamp: any) => {
        if (!timestamp) return '';
        const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
        const now = new Date();
        const diff = now.getTime() - date.getTime();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const timeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        
        // If today, just show time
        if (diff < 86400000) { // 24 hours
            return timeStr;
        }
        // If yesterday
        if (diff < 172800000) { // 48 hours
            return `Yesterday ${timeStr}`;
        }
        // Otherwise show date
        return `${date.toLocaleDateString()} ${timeStr}`;
    };

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    const updateTypingStatus = async (isTyping: boolean) => {
      if (!currentUser?.uid) return;
      const chatRef = doc(db, 'chats', chat.id);
      await updateDoc(chatRef, {
        [`participantInfo.${currentUser.uid}.isTyping`]: isTyping
      });
    };

    const updateViewingProfileStatus = async (isViewingProfile: boolean) => {
      if (!currentUser?.uid) return;
      const chatRef = doc(db, 'chats', chat.id);
      await updateDoc(chatRef, {
        [`participantInfo.${currentUser.uid}.isViewingProfile`]: isViewingProfile
      });
    };

    const updateSelectingGifStatus = async (isSelectingGif: boolean) => {
      if (!currentUser?.uid) return;
      const chatRef = doc(db, 'chats', chat.id);
      await updateDoc(chatRef, {
        [`participantInfo.${currentUser.uid}.isSelectingGif`]: isSelectingGif
      });
    };
    
    const handleTyping = (e: React.ChangeEvent<HTMLInputElement>) => {
      setNewMessage(e.target.value);
      if (!typingTimeoutRef.current) {
        updateTypingStatus(true);
      } else {
// Fix: Use window.clearTimeout to avoid type conflicts with NodeJS.Timeout
        window.clearTimeout(typingTimeoutRef.current);
      }
// Fix: Use window.setTimeout to avoid type conflicts with NodeJS.Timeout
      typingTimeoutRef.current = window.setTimeout(() => {
        updateTypingStatus(false);
        typingTimeoutRef.current = null;
      }, 2000);
    };

    const handleSendGif = async (gifUrl: string) => {
        if (!currentUser) return;
        
        const messageData = {
            senderId: currentUser.uid,
            type: 'gif' as const,
            content: gifUrl,
            timestamp: serverTimestamp(),
        };

        await addDoc(collection(db, `chats/${chat.id}/messages`), messageData);
    };

    const handleReport = async (reason: string) => {
        if (!currentUser || !userProfile || !partnerId) {
            alert('Missing user information. Please try again.');
            return;
        }

        if (messages.length === 0) {
            alert('No messages to report. Please wait for messages to load.');
            return;
        }

        try {
            // Get partner profile
            const partnerProfileSnap = await getDoc(doc(db, 'users', partnerId));
            if (!partnerProfileSnap.exists()) {
                alert('Unable to find partner profile.');
                return;
            }
            const partnerData = partnerProfileSnap.data();

            // Create report with all chat messages and participant info
            const reportData = {
                chatId: chat.id,
                reportedBy: currentUser.uid,
                reportedByName: userProfile.username,
                reportedUser: partnerId,
                reportedUserName: partnerData.username || 'Unknown',
                reason: reason,
                timestamp: serverTimestamp(),
                status: 'pending',
                // Convert messages with Firestore timestamps to plain objects
                messages: messages.map(m => ({
                    id: m.id,
                    senderId: m.senderId,
                    type: m.type,
                    content: m.content,
                    timestamp: m.timestamp || serverTimestamp()
                })),
                participantProfiles: {
                    [currentUser.uid]: {
                        uid: userProfile.uid || currentUser.uid,
                        username: userProfile.username || 'Unknown',
                        email: userProfile.email || 'unknown@email.com',
                        admissionNumber: userProfile.admissionNumber || 'N/A',
                        gender: userProfile.gender || 'other'
                    },
                    [partnerId]: {
                        uid: partnerId,
                        username: partnerData.username || 'Unknown',
                        email: partnerData.email || 'unknown@email.com',
                        admissionNumber: partnerData.admissionNumber || 'N/A',
                        gender: partnerData.gender || 'other'
                    }
                }
            };

            await addDoc(collection(db, 'reports'), reportData);
            setSuccessMessage('Report submitted successfully. An admin will review it soon.');
            setShowSuccessModal(true);
        } catch (error: any) {
            console.error('Error submitting report:', error);
            alert(`Failed to submit report: ${error.message || 'Please try again.'}`);
        }
    };

    const handleOpenProfile = () => {
        setShowProfileModal(true);
        updateViewingProfileStatus(true);
    };

    const handleCloseProfile = () => {
        setShowProfileModal(false);
        updateViewingProfileStatus(false);
    };

    const handleBlockUser = async () => {
        if (!currentUser || !partnerId) return;
        
        try {
            // Add partner to blocked list
            const userRef = doc(db, 'users', currentUser.uid);
            const currentBlockedUsers = userProfile?.blockedUsers || [];
            
            await updateDoc(userRef, {
                blockedUsers: [...currentBlockedUsers, partnerId]
            });

            alert('User blocked successfully. You will not be matched with them again.');
            
            // Leave the chat
            handleLeaveClick();
        } catch (error: any) {
            console.error('Error blocking user:', error);
            alert('Failed to block user. Please try again.');
        }
    };

    const handleSelectEmoji = (emoji: string) => {
        setNewMessage(prev => prev + emoji);
    };

    const handleSendMessage = async (e: FormEvent) => {
        e.preventDefault();
        if (!newMessage.trim() || !currentUser) return;
        
        updateTypingStatus(false);
// Fix: Use window.clearTimeout to avoid type conflicts with NodeJS.Timeout
        if(typingTimeoutRef.current) window.clearTimeout(typingTimeoutRef.current);

        const messageData: any = {
            senderId: currentUser.uid,
            type: 'text' as const,
            content: newMessage,
            timestamp: serverTimestamp(),
        };

        // Add reply info if replying to a message
        if (replyingTo) {
            messageData.replyTo = {
                messageId: replyingTo.id,
                content: replyingTo.content.substring(0, 50) + (replyingTo.content.length > 50 ? '...' : ''),
                senderId: replyingTo.senderId
            };
        }

        await addDoc(collection(db, `chats/${chat.id}/messages`), messageData);
        setNewMessage('');
        setReplyingTo(null);
    };

    const handleLeaveClick = () => {
        setShowLeaveConfirmation(true);
    };

    const handleConfirmLeave = async () => {
        if (!currentUser) return;
        
        try {
            // Send disconnect message before leaving
            await addDoc(collection(db, `chats/${chat.id}/messages`), {
                senderId: 'system',
                content: `${userProfile?.username || 'User'} has disconnected from the chat.`,
                type: 'system',
                timestamp: serverTimestamp()
            });

            // Small delay to ensure message is sent
            setTimeout(() => {
                setShowLeaveConfirmation(false);
                onLeave();
            }, 500);
        } catch (error) {
            console.error('Error sending disconnect message:', error);
            // Still leave even if message fails
            setShowLeaveConfirmation(false);
            onLeave();
        }
    };
    
    return (
        <div className="flex flex-col h-full bg-dark-card rounded-2xl shadow-xl overflow-hidden">
             <div className="p-4 bg-dark-surface flex justify-between items-center border-b border-dark-bg">
                <button 
                    onClick={handleOpenProfile}
                    className="flex items-center hover:bg-dark-bg/50 rounded-lg p-2 -ml-2 transition-colors group"
                >
                    {partnerProfile?.avatarUrl ? (
                        <img 
                            src={partnerProfile.avatarUrl} 
                            alt="Partner" 
                            className="w-10 h-10 rounded-full border-2 border-brand-primary object-cover mr-3"
                        />
                    ) : (
                        <div className={`w-10 h-10 ${
                            ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500', 'bg-pink-500', 'bg-indigo-500', 'bg-teal-500'][
                                (partnerId || '').split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 8
                            ]
                        } rounded-full flex items-center justify-center text-white text-sm font-bold border-2 border-brand-primary mr-3`}>
                            {partnerInfo.username.slice(0, 2).toUpperCase()}
                        </div>
                    )}
                    <div className="text-left">
                        <h2 className="font-bold text-white group-hover:text-brand-primary transition-colors">{partnerInfo.username}</h2>
                         <div className={`flex items-center text-xs ${
                           isPartnerSelectingGif ? 'text-yellow-400' : isPartnerViewingProfile ? 'text-purple-400' : isPartnerOnline ? 'text-green-400' : 'text-gray-500'
                         }`}>
                           <div className={`h-2 w-2 ${
                             isPartnerSelectingGif ? 'bg-yellow-400' : isPartnerViewingProfile ? 'bg-purple-400' : isPartnerOnline ? 'bg-green-400' : 'bg-gray-500'
                           } rounded-full mr-1.5`}></div> 
                           {isPartnerSelectingGif ? 'Selecting GIF...' : isPartnerViewingProfile ? 'Viewing Profile' : isPartnerOnline ? 'Online' : 'Offline'}
                        </div>
                    </div>
                </button>
                <div className="flex items-center space-x-3">
                  <div className="flex items-center text-sm text-dark-text-secondary"><Clock size={16} className="mr-1.5"/>{formatDuration(chatDuration)}</div>
                  <button 
                    onClick={() => setShowReportModal(true)} 
                    className="bg-dark-bg hover:bg-red-500/20 text-dark-text-secondary hover:text-red-500 p-2 rounded-lg transition-colors"
                    title="Report User"
                  >
                    <Flag size={18} />
                  </button>
                  <button onClick={handleLeaveClick} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Leave Chat</button>
                </div>
            </div>
            {showLeaveConfirmation && <LeaveConfirmationModal onConfirm={handleConfirmLeave} onCancel={() => setShowLeaveConfirmation(false)} />}
            {showReportModal && <ReportModal onClose={() => setShowReportModal(false)} onSubmit={handleReport} />}
            {showSuccessModal && <SuccessModal message={successMessage} onClose={() => setShowSuccessModal(false)} />}
            {showProfileModal && partnerProfile && <ProfileModal profile={partnerProfile} onClose={handleCloseProfile} onBlock={handleBlockUser} />}
            <div className="flex-1 p-4 overflow-y-auto space-y-4">
                {messages.map((msg, index) => (
                    msg.type === 'system' ? (
                        <div key={msg.id} className="flex justify-center">
                            <div className="bg-yellow-500/10 border border-yellow-500/30 text-yellow-400 px-4 py-2 rounded-lg text-sm text-center max-w-md">
                                <AlertTriangle size={14} className="inline mr-1.5" />
                                {msg.content}
                            </div>
                        </div>
                    ) : (
                        <div key={msg.id} className={`flex ${msg.senderId === currentUser?.uid ? 'justify-end' : 'justify-start'} group`}>
                            <div className="relative flex items-end gap-2">
                                {/* Reply Button */}
                                <button
                                    onClick={() => setReplyingTo(msg)}
                                    className={`opacity-0 group-hover:opacity-100 transition-opacity p-1.5 rounded-lg bg-dark-bg/80 hover:bg-dark-surface text-dark-text-secondary hover:text-brand-primary ${msg.senderId === currentUser?.uid ? 'order-first' : 'order-last'}`}
                                    title="Reply"
                                >
                                    <CornerDownLeft size={14} />
                                </button>
                                
                                <div>
                                    <div 
                                        className={`max-w-xs lg:max-w-md p-3 rounded-2xl ${msg.senderId === currentUser?.uid ? 'bg-brand-primary text-white rounded-br-none' : 'bg-dark-surface text-dark-text-primary rounded-bl-none'}`}
                                        title={formatMessageTime(msg.timestamp)}
                                    >
                                        {/* Show replied message if this is a reply */}
                                        {msg.replyTo && (
                                            <div className={`mb-2 pb-2 border-l-2 pl-2 text-xs opacity-70 ${msg.senderId === currentUser?.uid ? 'border-white/50' : 'border-brand-primary'}`}>
                                                <div className="font-semibold">{msg.replyTo.senderId === currentUser?.uid ? 'You' : partnerInfo.username}</div>
                                                <div className="truncate">{msg.replyTo.content}</div>
                                            </div>
                                        )}
                                        
                                        {msg.type === 'image' ? (
                                            <img src={msg.content} alt="chat attachment" className="rounded-lg max-h-64 cursor-pointer" onClick={() => window.open(msg.content, '_blank')} />
                                        ) : msg.type === 'gif' ? (
                                            <img src={msg.content} alt="GIF" className="rounded-lg max-h-48 cursor-pointer" onClick={() => window.open(msg.content, '_blank')} />
                                        ) : (
                                            <p className="whitespace-pre-wrap">{msg.content}</p>
                                        )}
                                    </div>
                                    <div className={`absolute -bottom-5 text-[10px] text-dark-text-secondary opacity-0 group-hover:opacity-100 transition-opacity ${msg.senderId === currentUser?.uid ? 'right-0' : 'left-0'}`}>
                                        {formatMessageTime(msg.timestamp)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )
                ))}
                 {isPartnerTyping && (
                    <div className="flex justify-start">
                        <div className="bg-dark-surface text-dark-text-primary rounded-2xl rounded-bl-none p-3">
                            <div className="flex items-center space-x-1">
                               <div className="h-2 w-2 bg-gray-400 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
                               <div className="h-2 w-2 bg-gray-400 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
                               <div className="h-2 w-2 bg-gray-400 rounded-full animate-bounce"></div>
                            </div>
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>
            <div className="bg-dark-surface border-t border-dark-bg relative">
                {showGifPicker && <GifPicker onSelectGif={handleSendGif} onClose={() => {setShowGifPicker(false); setShowEmojiPicker(false); updateSelectingGifStatus(false);}} />}
                {showEmojiPicker && <EmojiPicker onSelectEmoji={handleSelectEmoji} onClose={() => {setShowEmojiPicker(false); setShowGifPicker(false);}} />}
                
                {/* Reply Preview */}
                {replyingTo && (
                    <div className="px-4 pt-3 pb-2 bg-dark-bg/50 border-b border-dark-surface flex items-center justify-between">
                        <div className="flex items-center space-x-2 flex-1 min-w-0">
                            <CornerDownLeft size={16} className="text-brand-primary flex-shrink-0" />
                            <div className="flex-1 min-w-0">
                                <div className="text-xs text-brand-primary font-semibold">
                                    Replying to {replyingTo.senderId === currentUser?.uid ? 'yourself' : partnerInfo.username}
                                </div>
                                <div className="text-xs text-dark-text-secondary truncate">
                                    {replyingTo.content}
                                </div>
                            </div>
                        </div>
                        <button
                            onClick={() => setReplyingTo(null)}
                            className="text-dark-text-secondary hover:text-white transition-colors p-1"
                        >
                            <X size={16} />
                        </button>
                    </div>
                )}
                
                <form onSubmit={handleSendMessage} className="p-4 flex items-center space-x-2">
                    <button 
                        type="button" 
                        onClick={() => {setShowEmojiPicker(!showEmojiPicker); setShowGifPicker(false);}} 
                        className={`p-2.5 rounded-lg transition-all border ${showEmojiPicker ? 'bg-brand-primary text-white border-brand-primary' : 'bg-dark-bg hover:bg-brand-primary/20 text-dark-text-secondary hover:text-brand-primary border-dark-surface hover:border-brand-primary'}`}
                        title="Emoji"
                    >
                        <Smile size={18} />
                    </button>
                    <button 
                        type="button" 
                        onClick={() => {
                            const newState = !showGifPicker;
                            setShowGifPicker(newState);
                            setShowEmojiPicker(false);
                            updateSelectingGifStatus(newState);
                        }} 
                        className={`px-3 py-2 rounded-lg transition-all font-bold text-xs border ${showGifPicker ? 'bg-brand-primary text-white border-brand-primary' : 'bg-dark-bg hover:bg-brand-primary/20 text-dark-text-secondary hover:text-brand-primary border-dark-surface hover:border-brand-primary'}`}
                        title="Send GIF"
                    >
                        GIF
                    </button>
                    <input 
                        type="text" 
                        value={newMessage} 
                        onChange={handleTyping} 
                        placeholder="Type a message..." 
                        className="flex-1 bg-dark-bg text-white p-3 px-4 rounded-full border border-dark-surface focus:outline-none focus:ring-2 focus:ring-brand-primary focus:border-transparent placeholder-dark-text-secondary" 
                    />
                    <button 
                        type="submit" 
                        className="bg-brand-primary text-white p-3 rounded-full hover:bg-brand-secondary transition-colors disabled:opacity-50 disabled:cursor-not-allowed" 
                        disabled={!newMessage.trim()}
                    >
                        <Send size={20} />
                    </button>
                </form>
            </div>
        </div>
    );
};

// --- Main Chat Page Component ---
const ChatPage: React.FC = () => {
    const { currentUser, userProfile } = useAuth();
    const [isMatching, setIsMatching] = useState(false);
    const [currentChat, setCurrentChat] = useState<Chat | null>(null);
    const [showWarningModal, setShowWarningModal] = useState(false);
    const [warningMessage, setWarningMessage] = useState('');

    // Real-time listener for admin warnings
    useEffect(() => {
        if (!currentUser) return;
        
        const userRef = doc(db, 'users', currentUser.uid);
        const unsubscribe = onSnapshot(userRef, (docSnapshot) => {
            const userData = docSnapshot.data();
            if (userData?.warningMessage) {
                setWarningMessage(userData.warningMessage);
                setShowWarningModal(true);
            }
        });

        return () => unsubscribe();
    }, [currentUser]);

    // Handle warning acknowledgment
    const handleAcknowledgeWarning = async () => {
        if (!currentUser) return;
        
        try {
            const userRef = doc(db, 'users', currentUser.uid);
            await updateDoc(userRef, {
                warningMessage: null,
                warningTimestamp: null
            });
            setShowWarningModal(false);
            setWarningMessage('');
        } catch (error) {
            console.error('Error clearing warning:', error);
        }
    };

    // Set user presence with heartbeat
    useEffect(() => {
        if (!currentUser) return;
        const userStatusRef = doc(db, 'users', currentUser.uid);
        
        // Set online immediately
        updateDoc(userStatusRef, { 
            isOnline: true,
            lastSeen: serverTimestamp()
        });
        
        // Update lastSeen every 30 seconds as heartbeat
        const heartbeatInterval = setInterval(() => {
            updateDoc(userStatusRef, { 
                isOnline: true,
                lastSeen: serverTimestamp()
            });
        }, 30000); // 30 seconds
        
        // Handle tab close/browser close
        const handleBeforeUnload = () => {
            // Use navigator.sendBeacon for reliable offline status update
            const data = JSON.stringify({ isOnline: false, lastSeen: Date.now() });
            navigator.sendBeacon(`https://firestore.googleapis.com/v1/projects/${db.app.options.projectId}/databases/(default)/documents/users/${currentUser.uid}`, data);
            
            // Fallback to updateDoc (may not always complete)
            updateDoc(userStatusRef, { 
                isOnline: false, 
                lastSeen: serverTimestamp()
            });
        };
        
        // Handle visibility change (tab switching)
        const handleVisibilityChange = () => {
            if (document.hidden) {
                updateDoc(userStatusRef, { 
                    isOnline: false,
                    lastSeen: serverTimestamp()
                });
            } else {
                updateDoc(userStatusRef, { 
                    isOnline: true,
                    lastSeen: serverTimestamp()
                });
            }
        };
        
        window.addEventListener('beforeunload', handleBeforeUnload);
        document.addEventListener('visibilitychange', handleVisibilityChange);

        return () => {
            clearInterval(heartbeatInterval);
            updateDoc(userStatusRef, { 
                isOnline: false,
                lastSeen: serverTimestamp()
            });
            window.removeEventListener('beforeunload', handleBeforeUnload);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }
    }, [currentUser]);

    // Listen for chat invitations
    useEffect(() => {
        if (!userProfile) return;
        
        console.log('üëÇ Setting up listener for currentChatId changes');
        
// Fix: Renamed `doc` to `userDoc` to avoid shadowing the imported `doc` function.
        const unsub = onSnapshot(doc(db, 'users', userProfile.uid), async (userDoc) => {
// Fix: Safely access data, as userDoc.data() can be undefined.
            const data = userDoc.data();
            console.log('üì° User doc updated:', { 
                currentChatId: data?.currentChatId, 
                existingChatId: currentChat?.id 
            });
            
            if (data?.currentChatId && data.currentChatId !== currentChat?.id) {
                console.log('üéØ New chat detected, fetching chat data...');
                const chatDoc = await getDoc(doc(db, 'chats', data.currentChatId));
                if (chatDoc.exists()) {
                    console.log('‚úÖ Chat loaded successfully');
// Fix: The spread of chatDoc.data() is now safe.
                    setCurrentChat({ id: chatDoc.id, ...chatDoc.data() } as Chat);
                    setIsMatching(false);
                } else {
                    console.log('‚ùå Chat document does not exist');
                }
            } else if (!data?.currentChatId) {
                console.log('üîö No active chat');
                setCurrentChat(null);
            }
        });
        return () => {
            console.log('üîå Cleaning up currentChatId listener');
            unsub();
        };
    }, [userProfile, currentChat?.id]);
    
    const handleStartChat = async (preference: GenderPreference) => {
        try {
            if (!currentUser || !userProfile) {
                console.log('‚ùå No currentUser or userProfile');
                return;
            }
            
            console.log('üîç Starting matchmaking:', {
                userId: currentUser.uid,
                username: userProfile.username,
                myGender: userProfile.gender,
                seeking: preference
            });
            
            setIsMatching(true);

            // Simplified matching: Get all waiting users and find a compatible match client-side
            // This avoids complex Firestore compound queries that require indexes
            console.log('üì• Fetching matchmaking queue...');
            const queueSnapshot = await getDocs(collection(db, 'matchmakingQueue'));
        
        console.log('üìã Queue size:', queueSnapshot.size, 'users waiting');
        
        // Fast matching: filter compatible users in memory
        const blockedUsers = userProfile.blockedUsers || [];
        const compatibleUsers = queueSnapshot.docs.filter(queueDoc => {
            if (queueDoc.id === currentUser.uid) return false;
            
            // Skip blocked users
            if (blockedUsers.includes(queueDoc.id)) {
                console.log('‚õî Skipping blocked user:', queueDoc.id);
                return false;
            }
            
            const data = queueDoc.data();
            const weAcceptThem = preference === 'any' || data.gender === preference;
            const theyAcceptUs = data.seeking === 'any' || data.seeking === userProfile.gender;
            
            return weAcceptThem && theyAcceptUs;
        });

        console.log('‚úÖ Found', compatibleUsers.length, 'compatible users');
        
        if (compatibleUsers.length > 0) {
            // Match found - pick first one
            const potentialMatch = compatibleUsers[0];
            const partnerId = potentialMatch.id;
            const partnerData = potentialMatch.data();
            
            console.log('üéâ Creating chat with user:', partnerId);

            // Fetch partner profile in parallel with chat creation setup
            const partnerProfileSnap = await getDoc(doc(db, 'users', partnerId));
            if(!partnerProfileSnap.exists()) {
                 console.log('‚ö†Ô∏è Partner profile not found, removing from queue');
                 await deleteDoc(potentialMatch.ref);
                 return;
            }
            const partnerProfile = partnerProfileSnap.data() as UserProfile;

            const chatRef = doc(collection(db, 'chats'));
            const chatData = {
                participants: [currentUser.uid, partnerId],
                participantInfo: {
                    [currentUser.uid]: { username: userProfile.username, isTyping: false },
                    [partnerId]: { username: partnerProfile.username, isTyping: false }
                },
                createdAt: serverTimestamp(),
                startedAt: serverTimestamp(),
            };
            
            console.log('üìù Writing batch updates...');
            const batch = writeBatch(db);
            batch.set(chatRef, chatData);
            batch.update(doc(db, 'users', currentUser.uid), { currentChatId: chatRef.id, adsWatched: preference !== 'any' ? Math.max(0, userProfile.adsWatched - 1) : userProfile.adsWatched });
            batch.update(doc(db, 'users', partnerId), { currentChatId: chatRef.id });
            batch.delete(potentialMatch.ref);
            await batch.commit();
            console.log('‚úÖ Chat created successfully!');

        } else {
            // No match found, add to queue
            console.log('‚è≥ No match found, adding to queue...');
            await setDoc(doc(db, 'matchmakingQueue', currentUser.uid), {
                userId: currentUser.uid,
                timestamp: serverTimestamp(),
                gender: userProfile.gender,
                seeking: preference,
            });
            console.log('‚úÖ Added to matchmaking queue');
        }
        } catch (error: any) {
            console.error('‚ùå ERROR in handleStartChat:', error);
            console.error('Error code:', error?.code);
            console.error('Error message:', error?.message);
            console.error('Error stack:', error?.stack);
            setIsMatching(false);
            alert(`Matchmaking failed: ${error?.message || 'Unknown error'}. Check Firestore rules.`);
        }
    };
    
    const handleCancelMatchmaking = async () => {
        if (!currentUser) return;
        setIsMatching(false);
        await deleteDoc(doc(db, 'matchmakingQueue', currentUser.uid));
    };

    const handleLeaveChat = async () => {
        if (!currentUser || !currentChat) return;

        const chatRef = doc(db, 'chats', currentChat.id);
        
        // Use batch to update users and delete chat docs for atomicity
        const batch = writeBatch(db);

        // Delete all messages in the chat
        const messagesQuery = query(collection(db, `chats/${currentChat.id}/messages`));
        const messagesSnapshot = await getDocs(messagesQuery);
        messagesSnapshot.forEach(doc => batch.delete(doc.ref));

        // Delete the chat itself
        batch.delete(chatRef);

        // Update participant statuses
        currentChat.participants.forEach(uid => {
            batch.update(doc(db, 'users', uid), { currentChatId: null });
        });

        await batch.commit();
        setCurrentChat(null);
    };

    const handleWatchAd = async () => {
        if (!currentUser || !userProfile) return;
        // Simulate watching an ad
        await new Promise(res => setTimeout(res, 1500));
        await updateDoc(doc(db, 'users', currentUser.uid), {
            adsWatched: (userProfile.adsWatched || 0) + 1
        });
    }

    return (
        <div className="relative min-h-screen bg-dark-bg bg-grid-dark-surface/[0.2] flex flex-col items-center justify-center">
            <div className="absolute pointer-events-none inset-0 flex items-center justify-center bg-dark-bg [mask-image:radial-gradient(ellipse_at_center,transparent_20%,black)]"></div>
            <Header userProfile={userProfile} />
            {showWarningModal && <WarningNotificationModal message={warningMessage} onClose={handleAcknowledgeWarning} />}
            <main className="w-full h-screen pt-20 pb-4 px-4 z-10 flex items-center justify-center">
                {isMatching && <MatchmakingModal onCancel={handleCancelMatchmaking} />}
                {!currentChat ? (
                    <ChatDashboard onStartChat={handleStartChat} onWatchAd={handleWatchAd}/>
                ) : (
                    <div className="w-full max-w-4xl h-full">
                      <ChatRoom chat={currentChat} onLeave={handleLeaveChat} />
                    </div>
                )}
            </main>
        </div>
    );
};

export default ChatPage;